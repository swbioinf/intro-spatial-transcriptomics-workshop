# Normalisation and scaling

![](images/workflows/03_normalisation.png){width=100%}

## Learning objectives

## Overview

Before we dive into generating UMAP plots to visualise our spatial data we need to undertake a series of preprocessing steps. These steps are essential for transforming raw, high-dimensional data into a form that can be meaningfully interpreted. 

Why are these steps needed?

1. **Normalisation** Different cells have different total target counts. Normalisation allows them to be comparable.
2. **Identification of highly variable features (feature selection)**  Identifying the most variable features allows retaining the real biological variability of the data and reduce noise in the data.  
3. **Scaling the data**: Highly expressed genes can overpower the signal of other less expressed genes with equal importance. Within the same cell the assumption is that the underlying RNA content is constant. 

![](images/genes2umap.png){width=100%}

The difference between normalisation and scaling?
![](images/normandscale.png){width=100%}

## Reload data

To get started, lets launch a fresh R session, and load the libraries we need and the Seurat object form yesterday.

```{r echo=FALSE, results='hide', warnings=FALSE}
library(Seurat)
library(tidyverse)
library(here)

filtered_seurat_object_file <- here("data", "GSE234713_CosMx_IBD_seurat_02_rna70_neg4.RDS")
so    <- readRDS(filtered_seurat_object_file) 
```

## Normalisation


<!-- CHCEK IF FINAL OBJEWCT IS SPLIT BY NOW -- Start by 'splitting' the object so that each sample has its own assay again.  -->

<!-- ```{r  results='hide', warnings=FALSE} -->
<!-- # Basic preprocessing -->
<!-- # Split layers out again -->
<!-- # https://satijalab.org/seurat/articles/seurat5_integration -->
<!-- #so <- split(so, f = so$orig.ident) -->
<!-- ``` -->

By default, we will use the 'LogNormalize' method in seurat - as described in the NormaliseData function help:

> "LogNormalize: Feature counts for each cell are divided by the total counts for that cell and multiplied by the scale.factor. This is then natural-log transformed using log1'"


```{r message=FALSE}
so <- NormalizeData(so)
```


For a more in-depth discussion of normalisation in spatial datasets see [Atta et al (2024)](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-024-03303-w) and be aware of spatial-aware methods such as [SpaNorm](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-025-03565-y)




## Find Highly variable genes.


Which genes vary between cell types/states in our sample? 

We don't yet know anything about celltypes or stats, but we can make the assumption that the genes with high variance and are probably reflecting some biological state. In contrast a 'housekeeper' gene with even expression across all cell types won't be helpful in grouping our cells. 


Because we have our data split by sample, seurat will identify variable genes within each sample and combine that information. From the [seurat5 documentation on layers](https://satijalab.org/seurat/articles/seurat5_integration#layers-in-the-seurat-v5-object): 

> "Note that since the data is split into layers, normalization and variable feature identification is performed for each batch independently (a consensus set of variable features is automatically identified)."


```{r message=FALSE}
so <- FindVariableFeatures(so, nfeatures = 200)
```


Each point represents one gene - the red ones are our top 200 'highly variable genes' or HVGs. There is no firm rule on how many HVGs we want. For a whole transcriptome that could be 2000, for a 1000 genes we have 200. The exact number doesn't matter so much; so long as we capture the genes above the main group of low variance genes.


```{r}
VariableFeaturePlot(so)
```


We can list those genes:
```{r}
head(VariableFeatures(so))
```

## Scale data


By default, the scaleData function will scale only the HVGs.

```{r message=FALSE}
so <- ScaleData(so) # Just 200 variable features
```

Note the presence of the single 'scale.data' layer.

```{r}
so
```
